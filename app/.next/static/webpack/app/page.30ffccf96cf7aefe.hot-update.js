"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/use-game-events.ts":
/*!**************************************!*\
  !*** ./src/hooks/use-game-events.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useGameEvents: () => (/* binding */ useGameEvents)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tanstack/react-query */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js\");\n/* harmony import */ var _lib_events_to_game_event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/events/to-game-event */ \"(app-pages-browser)/./src/lib/events/to-game-event.ts\");\n/* harmony import */ var _lib_constants_routes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/constants/routes */ \"(app-pages-browser)/./src/lib/constants/routes.ts\");\n/* __next_internal_client_entry_do_not_use__ useGameEvents auto */ \n\n\n\nconst MAX_EVENTS = 200;\nconst MAX_RETRIES = 10;\nconst BASE_DELAY = 1000;\n/** All event types we listen for via named SSE events */ const EVENT_TYPES = [\n    \"GameUpdated\",\n    \"KeysPurchased\",\n    \"Claimed\",\n    \"ReferralEarned\",\n    \"ReferralClaimed\",\n    \"RoundStarted\",\n    \"RoundConcluded\",\n    \"ProtocolFeeCollected\"\n];\n/**\n * Central SSE subscription hook.\n *\n * Events are stored in chronological order (oldest first).\n * De-duplicated by event key (signature:index).\n * Returns { events, connected }.\n */ function useGameEvents() {\n    const [events, setEvents] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [connected, setConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const retryCount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const eventSourceRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const seenKeys = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Set());\n    const queryClient = (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_3__.useQueryClient)();\n    const handleProgramEvent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useGameEvents.useCallback[handleProgramEvent]\": (programEvent)=>{\n            // Update game state cache for GameUpdated events\n            if (programEvent.type === \"GameUpdated\") {\n                queryClient.setQueryData([\n                    \"gameState\"\n                ], {\n                    \"useGameEvents.useCallback[handleProgramEvent]\": (old)=>{\n                        if (!old) return old;\n                        const updatedGameState = {\n                            ...old.gameState,\n                            potLamports: programEvent.potLamports,\n                            totalKeys: programEvent.totalKeys,\n                            lastBuyer: programEvent.lastBuyer,\n                            timerEnd: programEvent.timerEnd,\n                            winnerPot: programEvent.winnerPot,\n                            nextRoundPot: programEvent.nextRoundPot\n                        };\n                        return {\n                            ...old,\n                            gameState: updatedGameState,\n                            keyPriceLamports: programEvent.nextKeyPrice,\n                            nextKeyPriceLamports: programEvent.nextKeyPrice\n                        };\n                    }\n                }[\"useGameEvents.useCallback[handleProgramEvent]\"]);\n            }\n            // Invalidate leaderboard and player state on buys/claims\n            if (programEvent.type === \"KeysPurchased\" || programEvent.type === \"Claimed\") {\n                queryClient.invalidateQueries({\n                    queryKey: [\n                        \"leaderboard\"\n                    ]\n                });\n                queryClient.invalidateQueries({\n                    queryKey: [\n                        \"playerState\"\n                    ]\n                });\n            }\n            // On round events, refetch game state entirely\n            if (programEvent.type === \"RoundStarted\" || programEvent.type === \"RoundConcluded\") {\n                queryClient.invalidateQueries({\n                    queryKey: [\n                        \"gameState\"\n                    ]\n                });\n            }\n            // Convert to feed event\n            const feedEvent = (0,_lib_events_to_game_event__WEBPACK_IMPORTED_MODULE_1__.toGameEvent)(programEvent);\n            if (!feedEvent) return;\n            // De-duplicate by key\n            if (seenKeys.current.has(feedEvent.id)) return;\n            seenKeys.current.add(feedEvent.id);\n            setEvents({\n                \"useGameEvents.useCallback[handleProgramEvent]\": (prev)=>{\n                    const next = [\n                        ...prev,\n                        feedEvent\n                    ];\n                    // Trim oldest events if over cap\n                    if (next.length > MAX_EVENTS) {\n                        const trimmed = next.slice(-MAX_EVENTS);\n                        // Rebuild seen keys from remaining events\n                        seenKeys.current = new Set(trimmed.map({\n                            \"useGameEvents.useCallback[handleProgramEvent]\": (e)=>e.id\n                        }[\"useGameEvents.useCallback[handleProgramEvent]\"]));\n                        return trimmed;\n                    }\n                    return next;\n                }\n            }[\"useGameEvents.useCallback[handleProgramEvent]\"]);\n        }\n    }[\"useGameEvents.useCallback[handleProgramEvent]\"], [\n        queryClient\n    ]);\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useGameEvents.useCallback[connect]\": ()=>{\n            if (eventSourceRef.current) {\n                eventSourceRef.current.close();\n            }\n            const es = new EventSource(_lib_constants_routes__WEBPACK_IMPORTED_MODULE_2__.API_ROUTES.EVENTS);\n            eventSourceRef.current = es;\n            es.onopen = ({\n                \"useGameEvents.useCallback[connect]\": ()=>{\n                    setConnected(true);\n                    retryCount.current = 0;\n                }\n            })[\"useGameEvents.useCallback[connect]\"];\n            // Listen for each named event type\n            for (const eventType of EVENT_TYPES){\n                es.addEventListener(eventType, {\n                    \"useGameEvents.useCallback[connect]\": (msg)=>{\n                        try {\n                            const data = JSON.parse(msg.data);\n                            handleProgramEvent(data);\n                        } catch (e) {\n                        // Ignore malformed events\n                        }\n                    }\n                }[\"useGameEvents.useCallback[connect]\"]);\n            }\n            es.onerror = ({\n                \"useGameEvents.useCallback[connect]\": ()=>{\n                    es.close();\n                    setConnected(false);\n                    if (retryCount.current < MAX_RETRIES) {\n                        const delay = BASE_DELAY * Math.pow(2, retryCount.current);\n                        retryCount.current++;\n                        setTimeout(connect, delay);\n                    }\n                }\n            })[\"useGameEvents.useCallback[connect]\"];\n        }\n    }[\"useGameEvents.useCallback[connect]\"], [\n        handleProgramEvent\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useGameEvents.useEffect\": ()=>{\n            connect();\n            return ({\n                \"useGameEvents.useEffect\": ()=>{\n                    var _eventSourceRef_current;\n                    (_eventSourceRef_current = eventSourceRef.current) === null || _eventSourceRef_current === void 0 ? void 0 : _eventSourceRef_current.close();\n                }\n            })[\"useGameEvents.useEffect\"];\n        }\n    }[\"useGameEvents.useEffect\"], [\n        connect\n    ]);\n    return {\n        events,\n        connected\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2UtZ2FtZS1ldmVudHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O21FQUVpRTtBQUNWO0FBSUU7QUFDTDtBQUVwRCxNQUFNTyxhQUFhO0FBQ25CLE1BQU1DLGNBQWM7QUFDcEIsTUFBTUMsYUFBYTtBQUVuQix1REFBdUQsR0FDdkQsTUFBTUMsY0FBa0M7SUFDdEM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQ7Ozs7OztDQU1DLEdBQ00sU0FBU0M7SUFDZCxNQUFNLENBQUNDLFFBQVFDLFVBQVUsR0FBR2IsK0NBQVFBLENBQWMsRUFBRTtJQUNwRCxNQUFNLENBQUNjLFdBQVdDLGFBQWEsR0FBR2YsK0NBQVFBLENBQUM7SUFDM0MsTUFBTWdCLGFBQWFkLDZDQUFNQSxDQUFDO0lBQzFCLE1BQU1lLGlCQUFpQmYsNkNBQU1BLENBQXFCO0lBQ2xELE1BQU1nQixXQUFXaEIsNkNBQU1BLENBQUMsSUFBSWlCO0lBQzVCLE1BQU1DLGNBQWNoQixxRUFBY0E7SUFFbEMsTUFBTWlCLHFCQUFxQmxCLGtEQUFXQTt5REFDcEMsQ0FBQ21CO1lBQ0MsaURBQWlEO1lBQ2pELElBQUlBLGFBQWFDLElBQUksS0FBSyxlQUFlO2dCQUN2Q0gsWUFBWUksWUFBWSxDQUN0QjtvQkFBQztpQkFBWTtxRUFDYixDQUFDQzt3QkFDQyxJQUFJLENBQUNBLEtBQUssT0FBT0E7d0JBQ2pCLE1BQU1DLG1CQUFtQjs0QkFDdkIsR0FBR0QsSUFBSUUsU0FBUzs0QkFDaEJDLGFBQWFOLGFBQWFNLFdBQVc7NEJBQ3JDQyxXQUFXUCxhQUFhTyxTQUFTOzRCQUNqQ0MsV0FBV1IsYUFBYVEsU0FBUzs0QkFDakNDLFVBQVVULGFBQWFTLFFBQVE7NEJBQy9CQyxXQUFXVixhQUFhVSxTQUFTOzRCQUNqQ0MsY0FBY1gsYUFBYVcsWUFBWTt3QkFDekM7d0JBQ0EsT0FBTzs0QkFDTCxHQUFHUixHQUFHOzRCQUNORSxXQUFX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Z2FtZS1ldmVudHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVF1ZXJ5Q2xpZW50IH0gZnJvbSBcIkB0YW5zdGFjay9yZWFjdC1xdWVyeVwiO1xuaW1wb3J0IHR5cGUgeyBHYW1lRXZlbnQgfSBmcm9tIFwiQC90eXBlcy9nYW1lXCI7XG5pbXBvcnQgdHlwZSB7IEdhbWVTdGF0ZVJlc3BvbnNlIH0gZnJvbSBcIkAvdHlwZXMvYXBpXCI7XG5pbXBvcnQgdHlwZSB7IFByb2dyYW1FdmVudCwgUHJvZ3JhbUV2ZW50VHlwZSB9IGZyb20gXCJAL3R5cGVzL3Byb2dyYW0tZXZlbnRzXCI7XG5pbXBvcnQgeyB0b0dhbWVFdmVudCB9IGZyb20gXCJAL2xpYi9ldmVudHMvdG8tZ2FtZS1ldmVudFwiO1xuaW1wb3J0IHsgQVBJX1JPVVRFUyB9IGZyb20gXCJAL2xpYi9jb25zdGFudHMvcm91dGVzXCI7XG5cbmNvbnN0IE1BWF9FVkVOVFMgPSAyMDA7XG5jb25zdCBNQVhfUkVUUklFUyA9IDEwO1xuY29uc3QgQkFTRV9ERUxBWSA9IDEwMDA7XG5cbi8qKiBBbGwgZXZlbnQgdHlwZXMgd2UgbGlzdGVuIGZvciB2aWEgbmFtZWQgU1NFIGV2ZW50cyAqL1xuY29uc3QgRVZFTlRfVFlQRVM6IFByb2dyYW1FdmVudFR5cGVbXSA9IFtcbiAgXCJHYW1lVXBkYXRlZFwiLFxuICBcIktleXNQdXJjaGFzZWRcIixcbiAgXCJDbGFpbWVkXCIsXG4gIFwiUmVmZXJyYWxFYXJuZWRcIixcbiAgXCJSZWZlcnJhbENsYWltZWRcIixcbiAgXCJSb3VuZFN0YXJ0ZWRcIixcbiAgXCJSb3VuZENvbmNsdWRlZFwiLFxuICBcIlByb3RvY29sRmVlQ29sbGVjdGVkXCIsXG5dO1xuXG4vKipcbiAqIENlbnRyYWwgU1NFIHN1YnNjcmlwdGlvbiBob29rLlxuICpcbiAqIEV2ZW50cyBhcmUgc3RvcmVkIGluIGNocm9ub2xvZ2ljYWwgb3JkZXIgKG9sZGVzdCBmaXJzdCkuXG4gKiBEZS1kdXBsaWNhdGVkIGJ5IGV2ZW50IGtleSAoc2lnbmF0dXJlOmluZGV4KS5cbiAqIFJldHVybnMgeyBldmVudHMsIGNvbm5lY3RlZCB9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlR2FtZUV2ZW50cygpIHtcbiAgY29uc3QgW2V2ZW50cywgc2V0RXZlbnRzXSA9IHVzZVN0YXRlPEdhbWVFdmVudFtdPihbXSk7XG4gIGNvbnN0IFtjb25uZWN0ZWQsIHNldENvbm5lY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IHJldHJ5Q291bnQgPSB1c2VSZWYoMCk7XG4gIGNvbnN0IGV2ZW50U291cmNlUmVmID0gdXNlUmVmPEV2ZW50U291cmNlIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IHNlZW5LZXlzID0gdXNlUmVmKG5ldyBTZXQ8c3RyaW5nPigpKTtcbiAgY29uc3QgcXVlcnlDbGllbnQgPSB1c2VRdWVyeUNsaWVudCgpO1xuXG4gIGNvbnN0IGhhbmRsZVByb2dyYW1FdmVudCA9IHVzZUNhbGxiYWNrKFxuICAgIChwcm9ncmFtRXZlbnQ6IFByb2dyYW1FdmVudCkgPT4ge1xuICAgICAgLy8gVXBkYXRlIGdhbWUgc3RhdGUgY2FjaGUgZm9yIEdhbWVVcGRhdGVkIGV2ZW50c1xuICAgICAgaWYgKHByb2dyYW1FdmVudC50eXBlID09PSBcIkdhbWVVcGRhdGVkXCIpIHtcbiAgICAgICAgcXVlcnlDbGllbnQuc2V0UXVlcnlEYXRhPEdhbWVTdGF0ZVJlc3BvbnNlPihcbiAgICAgICAgICBbXCJnYW1lU3RhdGVcIl0sXG4gICAgICAgICAgKG9sZCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFvbGQpIHJldHVybiBvbGQ7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkR2FtZVN0YXRlID0ge1xuICAgICAgICAgICAgICAuLi5vbGQuZ2FtZVN0YXRlLFxuICAgICAgICAgICAgICBwb3RMYW1wb3J0czogcHJvZ3JhbUV2ZW50LnBvdExhbXBvcnRzLFxuICAgICAgICAgICAgICB0b3RhbEtleXM6IHByb2dyYW1FdmVudC50b3RhbEtleXMsXG4gICAgICAgICAgICAgIGxhc3RCdXllcjogcHJvZ3JhbUV2ZW50Lmxhc3RCdXllcixcbiAgICAgICAgICAgICAgdGltZXJFbmQ6IHByb2dyYW1FdmVudC50aW1lckVuZCxcbiAgICAgICAgICAgICAgd2lubmVyUG90OiBwcm9ncmFtRXZlbnQud2lubmVyUG90LFxuICAgICAgICAgICAgICBuZXh0Um91bmRQb3Q6IHByb2dyYW1FdmVudC5uZXh0Um91bmRQb3QsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgICAgICBnYW1lU3RhdGU6IHVwZGF0ZWRHYW1lU3RhdGUsXG4gICAgICAgICAgICAgIGtleVByaWNlTGFtcG9ydHM6IHByb2dyYW1FdmVudC5uZXh0S2V5UHJpY2UsXG4gICAgICAgICAgICAgIG5leHRLZXlQcmljZUxhbXBvcnRzOiBwcm9ncmFtRXZlbnQubmV4dEtleVByaWNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIEludmFsaWRhdGUgbGVhZGVyYm9hcmQgYW5kIHBsYXllciBzdGF0ZSBvbiBidXlzL2NsYWltc1xuICAgICAgaWYgKFxuICAgICAgICBwcm9ncmFtRXZlbnQudHlwZSA9PT0gXCJLZXlzUHVyY2hhc2VkXCIgfHxcbiAgICAgICAgcHJvZ3JhbUV2ZW50LnR5cGUgPT09IFwiQ2xhaW1lZFwiXG4gICAgICApIHtcbiAgICAgICAgcXVlcnlDbGllbnQuaW52YWxpZGF0ZVF1ZXJpZXMoeyBxdWVyeUtleTogW1wibGVhZGVyYm9hcmRcIl0gfSk7XG4gICAgICAgIHF1ZXJ5Q2xpZW50LmludmFsaWRhdGVRdWVyaWVzKHsgcXVlcnlLZXk6IFtcInBsYXllclN0YXRlXCJdIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBPbiByb3VuZCBldmVudHMsIHJlZmV0Y2ggZ2FtZSBzdGF0ZSBlbnRpcmVseVxuICAgICAgaWYgKFxuICAgICAgICBwcm9ncmFtRXZlbnQudHlwZSA9PT0gXCJSb3VuZFN0YXJ0ZWRcIiB8fFxuICAgICAgICBwcm9ncmFtRXZlbnQudHlwZSA9PT0gXCJSb3VuZENvbmNsdWRlZFwiXG4gICAgICApIHtcbiAgICAgICAgcXVlcnlDbGllbnQuaW52YWxpZGF0ZVF1ZXJpZXMoeyBxdWVyeUtleTogW1wiZ2FtZVN0YXRlXCJdIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBDb252ZXJ0IHRvIGZlZWQgZXZlbnRcbiAgICAgIGNvbnN0IGZlZWRFdmVudCA9IHRvR2FtZUV2ZW50KHByb2dyYW1FdmVudCk7XG4gICAgICBpZiAoIWZlZWRFdmVudCkgcmV0dXJuO1xuXG4gICAgICAvLyBEZS1kdXBsaWNhdGUgYnkga2V5XG4gICAgICBpZiAoc2VlbktleXMuY3VycmVudC5oYXMoZmVlZEV2ZW50LmlkKSkgcmV0dXJuO1xuICAgICAgc2VlbktleXMuY3VycmVudC5hZGQoZmVlZEV2ZW50LmlkKTtcblxuICAgICAgc2V0RXZlbnRzKChwcmV2KSA9PiB7XG4gICAgICAgIGNvbnN0IG5leHQgPSBbLi4ucHJldiwgZmVlZEV2ZW50XTtcbiAgICAgICAgLy8gVHJpbSBvbGRlc3QgZXZlbnRzIGlmIG92ZXIgY2FwXG4gICAgICAgIGlmIChuZXh0Lmxlbmd0aCA+IE1BWF9FVkVOVFMpIHtcbiAgICAgICAgICBjb25zdCB0cmltbWVkID0gbmV4dC5zbGljZSgtTUFYX0VWRU5UUyk7XG4gICAgICAgICAgLy8gUmVidWlsZCBzZWVuIGtleXMgZnJvbSByZW1haW5pbmcgZXZlbnRzXG4gICAgICAgICAgc2VlbktleXMuY3VycmVudCA9IG5ldyBTZXQodHJpbW1lZC5tYXAoKGUpID0+IGUuaWQpKTtcbiAgICAgICAgICByZXR1cm4gdHJpbW1lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgW3F1ZXJ5Q2xpZW50XVxuICApO1xuXG4gIGNvbnN0IGNvbm5lY3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGV2ZW50U291cmNlUmVmLmN1cnJlbnQpIHtcbiAgICAgIGV2ZW50U291cmNlUmVmLmN1cnJlbnQuY2xvc2UoKTtcbiAgICB9XG5cbiAgICBjb25zdCBlcyA9IG5ldyBFdmVudFNvdXJjZShBUElfUk9VVEVTLkVWRU5UUyk7XG4gICAgZXZlbnRTb3VyY2VSZWYuY3VycmVudCA9IGVzO1xuXG4gICAgZXMub25vcGVuID0gKCkgPT4ge1xuICAgICAgc2V0Q29ubmVjdGVkKHRydWUpO1xuICAgICAgcmV0cnlDb3VudC5jdXJyZW50ID0gMDtcbiAgICB9O1xuXG4gICAgLy8gTGlzdGVuIGZvciBlYWNoIG5hbWVkIGV2ZW50IHR5cGVcbiAgICBmb3IgKGNvbnN0IGV2ZW50VHlwZSBvZiBFVkVOVF9UWVBFUykge1xuICAgICAgZXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIChtc2c6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKG1zZy5kYXRhKSBhcyBQcm9ncmFtRXZlbnQ7XG4gICAgICAgICAgaGFuZGxlUHJvZ3JhbUV2ZW50KGRhdGEpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAvLyBJZ25vcmUgbWFsZm9ybWVkIGV2ZW50c1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBlcy5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgZXMuY2xvc2UoKTtcbiAgICAgIHNldENvbm5lY3RlZChmYWxzZSk7XG5cbiAgICAgIGlmIChyZXRyeUNvdW50LmN1cnJlbnQgPCBNQVhfUkVUUklFUykge1xuICAgICAgICBjb25zdCBkZWxheSA9IEJBU0VfREVMQVkgKiBNYXRoLnBvdygyLCByZXRyeUNvdW50LmN1cnJlbnQpO1xuICAgICAgICByZXRyeUNvdW50LmN1cnJlbnQrKztcbiAgICAgICAgc2V0VGltZW91dChjb25uZWN0LCBkZWxheSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2hhbmRsZVByb2dyYW1FdmVudF0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29ubmVjdCgpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBldmVudFNvdXJjZVJlZi5jdXJyZW50Py5jbG9zZSgpO1xuICAgIH07XG4gIH0sIFtjb25uZWN0XSk7XG5cbiAgcmV0dXJuIHsgZXZlbnRzLCBjb25uZWN0ZWQgfTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZUNhbGxiYWNrIiwidXNlUXVlcnlDbGllbnQiLCJ0b0dhbWVFdmVudCIsIkFQSV9ST1VURVMiLCJNQVhfRVZFTlRTIiwiTUFYX1JFVFJJRVMiLCJCQVNFX0RFTEFZIiwiRVZFTlRfVFlQRVMiLCJ1c2VHYW1lRXZlbnRzIiwiZXZlbnRzIiwic2V0RXZlbnRzIiwiY29ubmVjdGVkIiwic2V0Q29ubmVjdGVkIiwicmV0cnlDb3VudCIsImV2ZW50U291cmNlUmVmIiwic2VlbktleXMiLCJTZXQiLCJxdWVyeUNsaWVudCIsImhhbmRsZVByb2dyYW1FdmVudCIsInByb2dyYW1FdmVudCIsInR5cGUiLCJzZXRRdWVyeURhdGEiLCJvbGQiLCJ1cGRhdGVkR2FtZVN0YXRlIiwiZ2FtZVN0YXRlIiwicG90TGFtcG9ydHMiLCJ0b3RhbEtleXMiLCJsYXN0QnV5ZXIiLCJ0aW1lckVuZCIsIndpbm5lclBvdCIsIm5leHRSb3VuZFBvdCIsImtleVByaWNlTGFtcG9ydHMiLCJuZXh0S2V5UHJpY2UiLCJuZXh0S2V5UHJpY2VMYW1wb3J0cyIsImludmFsaWRhdGVRdWVyaWVzIiwicXVlcnlLZXkiLCJmZWVkRXZlbnQiLCJjdXJyZW50IiwiaGFzIiwiaWQiLCJhZGQiLCJwcmV2IiwibmV4dCIsImxlbmd0aCIsInRyaW1tZWQiLCJzbGljZSIsIm1hcCIsImUiLCJjb25uZWN0IiwiY2xvc2UiLCJlcyIsIkV2ZW50U291cmNlIiwiRVZFTlRTIiwib25vcGVuIiwiZXZlbnRUeXBlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm1zZyIsImRhdGEiLCJKU09OIiwicGFyc2UiLCJvbmVycm9yIiwiZGVsYXkiLCJNYXRoIiwicG93Iiwic2V0VGltZW91dCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/use-game-events.ts\n"));

/***/ })

});